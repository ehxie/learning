# Introduction

## Linux 版本

`在 2.5 之前`，Linux 都通过简单的编号来区别内核的稳定版和开发版。每个版本号都用三个数字描述，用点分隔

- 前两个数字表示`版本号`
  - 第一个数字版本号 2 从 1996 开始就没有变过
  - 第二个数字表示内核类型：偶数是稳定的内核，否则是开发版
- 第一个表示`发布号`

`2.6` 开始内核版本的编号发生了变化

- 第二个数字不再用于表示内核时稳定版本还是开发版，因此，现在内核开发者都在当前的 2.6 版本中对内核进行大幅改进。
  - 只有内核开发者必须对内核的重大修改进行测试时，才是采用一个新的内核分支 2.7。这种 2.7 的分支要么产生一个新的内核版本，要么干脆丢弃退回到 2.6

Linux 新的开发模式意味着两种内核具有相同的版本号，但却有不同的发布号

- 例如，2.6.10 和 2.6.11 内核可能在核心部件和基本算法上有很大的差别。
- 这样一来新的发布号的内核可能潜藏着不稳定性和各种错误。为了解决这个问题，内核开发者可能发布带有补丁程序的内核版本，并且使用第四位数字表示带有不同补丁的内核版本（例如 2.6.11.12)

本文基于 2.6.11 版本的内核

## 操作系统基本概念

任何计算机系统都包含一个名为操作系统的`基本程序集合`

- 在这个集合里，最主要的程序称为`内核(kernel)`
  - 当操作系统启动时，内核被装入到 RAM 中，内核中包含了系统运行所必不可少的很多核心过程(procedure)
- 其他重新是一些不太重要的实用程序

操作系统必须完成两个目标

- 与硬件部分交互，为包含在硬件平台上的所有低层可编程部件提供服务
- 为运行在计算机系统上的应用程序(即所谓用户程序)提供执行环境

一些操作系统允许用户程序直接与硬件部分进行交互(例如 MS-DOS)，与此相反，类 Unix 系统把计算机屋里组织相关的所有低层细节都对用户运行的程序隐藏起来

- 当应用程序想要使用硬件资源时，必须向操作系统发出一个请求，内核会对此请求进行评估，如果允许使用则内核代表应用程序与相关的硬件部分进行交互。
  - 为了实现这种机制，现代操作系统依靠特殊的硬件特性来禁用用户程序直接与低层硬件部分进行交互，或禁止直接访问任意的物理地址。硬件为 CPU 引入了至少两种不同的执行模式：用户程序的非特权模式和内核的特权模式。Unix 分别称他们为用户模式(User Mode)和内核模式(Kernel Mode)

### 多用户系统

多用户系统(multi-user system)：一台能并发和独立执行分别属于两个或多个用户的若干应用程序的计算机

- 并发(concurrently)：意味着几个应用程序能同时处于活动状态并竞争各种资源，如 CPU、内存和 I/O 设备
- 独立(independently)：意味着每个应用程序能执行自己的任务，而无需考虑其他用户的应用程序都在干什么

多用户操作系统必须包含以下特点：

- 核实用户身份的认证机制
- 防止有错误的用户程序妨碍其他应用程序在系统中运行的保护机制
- 防止有恶意的用户程序干涉或窥视其他用户的活动的保护机制
- 限制分配给每个用户的资源数的记帐机制

为了实现这些机制，操作系统必须利用与 CPU 特权模式相关的硬件保护机制，否则用户程序将能直接访问系统电路并克服强加给它的这些限制

- Unix 是实施系统资源硬件保护的多用户系统

### 用户和组

在多用户系统中，每个用户在机器上都有私有空间；即拥有一定数量的磁控空间来存储文件、接收私人信息等等。操作系统必须保证用户空间的私有部分仅仅对其拥有者是可见的

- 特别必须保证，没有用户能够开发一个用户侵犯其他用户私有空间的应用程序

所有的用户由一个唯一的数字来标识，这个数字叫用户标识符（User ID, 即 UID）

- 每个用户都有一个唯一的 UID，这个 UID 是系统管理员分配给用户的，在某个用户要开始新的工作会话时，操作系统通常要求输入登录名和口令，正确了才能访问

为了和其他用户有选择的共享资料，每个用户是一个或多个用户组的一名成员，组由唯一的用户组标识符(user group ID, 即 GID)来标识，每个文件恰好与一个组相对应

- 例如可以设置：对拥有文件的用户具有读写权限，同组用户仅有只读权限，其他用户没有任何访问权限

任何类 Unix 系统都有一个特殊的用户，叫做 root（即超级用户 superuser）

- 系统管理员必须以 root 身份登录，以便处理用户账号，完成诸如系统备份、程序升级等运维工作
- root 几乎无所不能，因为操作系统对他不使用通常的保护机制，因此 root 用户可以访问任何文件，能够干涉每一个正在执行的用户程序活动

### 进程

所有的操作系统都使用一种基本的抽象：进程(process)

- 进程可以定义为程序执行时的一个实例或者程序的执行上下文

> 在传统的操作系统中，一个进程在地址空间(address space)中执行一个单独的指令序列
>
> - 地址空间是允许进程引用的内存地址集合
>   现代操作系统允许具有多个执行流的进程，也就是说在相同的地址空间可执行多个指令序列

多用户系统必须实施一种执行环境，在这种环境里，几个进程能够并发活动，并能竞争系统资源(主要是 CPU)

- 允许程序并发活动的系统称为多道程序系统(multi-programming)或多处理系统(multi-processing)
- 区分程序和进程：程序是静态的，进程是动态的。几个进程能够并发地执行同一程序，而同一个进程能顺序的执行几个程序。

在单处理器系统上，只有一个进程能够占用 CPU，因此某个时刻只能有一个执行流

- 一般来说，CPU 的个数是有限的，因而只有少数几个进程能够同时执行
- 操作系统中叫做调度程序(scheduler)的部分决定哪个进程能够执行
  - 一些操作系统只允许非抢占式(nonpreemptive)进程，即当进程自愿放弃 CPU 时，调度程序才被调用
  - 但是多用户系统中的进程必须是抢占式(preemptable)，操作系统记录下每个进程占有的 CPU 时间，并周期性地激活调度程序

`Unix`是具有抢占式进程的多处理操作系统

- 即使没有登录，没有程序运行，也还是有几个系统进程在监视外围设备。尤其是，有几个进程在监听系统终端等待用户登录，当用户输入登录名，监听程序就会运行一个程序来验证用户的口令，如果用户身份得到证实，那么监听程序就会创建另一个进程来执行 shell，此时在 shell 下就可以输入命令

`类 Unix`系统采用进程/内核模式。

- 每个进程都自以为它是系统中唯一的进程，可以独占操作系统所提供的服务。只要进程发出系统调用(即对内核提出请求)，硬件就会把特权模式由用户态变成内核态。然后进程以非常有限的目的开始一个内核过程的执行。这样操作系统在进程的执行上下文中起作用，以满足进程的请求。一旦请求满足后，内核过程将迫使硬件返回用户态，然后进程从系统调用的下一条指令继续执行

### 内核体系结构

大部分 Unix 内核是单块结构：每一个内核层都被集成到整个内核程序中，并代表当前程序在内核态下运行

相反，微内核(micro kernel)操作系统只需要内核有一个很小的函数集，通常包括几个同步原语、一个简单的调度程序和进程间通信机制。

- 运行再微内核之上的几个系统进程实现从前操作系统实现的功能，如内存分配、设备驱动程序、系统调用处理程序等等

> 微内核的效率比单块结构的低，因为操作系统不同层次之间显示传递消息需要花费一定的时间
> 不过微内核也有优势：
>
> - 迫使程序员采用模块化得方法，因为任何操作系统层都是一个相对独立的程序，这种程序必须通过定义明确而清晰的软件接口与其他层交互
> - 微内核可以很容易的移植到其他的体系结构上，因为所有与硬件相关的部分都被封装进微内核代码中
> - 微内核更加充分地利用了 RAM，因为暂且不需要执行的系统进程可以被调出或撤销

为了达到微内核理论上的很多优点而又不影响性能，Linux 内核提供了模块(module)

- 模块是一个目标文件，其代码可以在运行时链接到内核或从内核解除链接。
- 这种目标代码通常由一个函数组成，用来实现文件系统、驱动程序或其他内核上层功能
- 与微内核操作系统的外层不同，模块不是作为一个特殊的进程执行的，而是和其他静态链接的内核函数一样，代表当前进程在在内核态下执行

模块的主要`优点`

- 模块化方法：因为任何模块都可以在`运行时`被动态链接或解除链接。因此系统程序员必须提出明确的软件接口以访问由模块处理的数据结构。这使得开发新模块变得容易
- 平台无关性：即使模块依赖于某些特殊的硬件特点，但它不依赖于某个固定的硬件平台
  - e.g.：符合 SCSI 标准的磁盘驱动程序模块，在 IBM 兼容 PC 与 HP 得 Alpha 机上都能很好的工作
- 节省内存使用：当需要模块功能时，把它动态链接到正在运行的内核，否则就解除链接。这种机制对于小型嵌入式系统非常游泳
- 无性能损失：模块的目标代码一旦被链接到内核，其作用与静态链接的内核的目标代码完全等价。因此当模块的函数被调用时，无需显示地进行消息传递
