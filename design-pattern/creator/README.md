## overview

创建型模式抽象了实例化的过程

- 帮助一个系统独立于如何创建、组合和表示它的哪些对象

> 类创建型模式：使用继承改变被实例化的类
>
> 对象创建型模式：将实例委托给另一个对象

一组固定行为的硬编码(hard-coding)转移为定义一个较小的基本行为集，这些行为可以被组合成任意数目的更复杂的行为

- 创建有特定行为的对象要求的不仅仅是实例化一个类

# example

为电脑游戏创建一个迷宫，迷宫和游戏随着各种模式的不同而略有区别

- 有时游戏仅仅是为了找到迷宫的一个出口，在这种情况下，游戏者可能看到的只是迷宫的一部分

- 有时迷宫包括一些要解决的问题和要战胜的危险，并且游戏可能会提供已经被探索过的那部分迷宫地图

我们忽略迷宫的细节，只关注迷宫是如何被创建的

定义

- 迷宫是一系列的房间，一个房间知道它的邻居，要么是另一个房间，要么是一堵墙，或者是到另一个房间的一扇门

具体实现在 [maze.ts](/design-pattern/creator/maze.ts)

![Alt text](/design-pattern/README.asserts/image.png)

# 改动
>
> 看到这里认为你已经看完 [maze.ts](/design-pattern/creator/maze.ts) 了

如果要新建一个施了魔法的迷宫，复用以上的布局，但是构件有新的构件，DoorNeedingSpell 是一扇只能通过咒语才能打开和锁上的门，EnchantedRoom 一个拥有魔法钥匙或者咒语的房间

要怎么改变 CreateMaze 才能用新类型创建魔法迷宫呢？

- Factory Method：让 CreateMaze 调用虚函数而不是构造器来创建所需要的房间、墙壁和门。创建一个 MazeGame 的子类并重新定义这些虚函数

- Abstract Factory：通过传递一个对象给 CreateMaze 来创建房间、墙壁和门（即可以通过传递不同的参数来改变房间、墙壁和门的类）

- Builder：如果传递一个对象给 CreateMaze，该对象可以在它所建造的迷宫总使用增加房间、墙壁和门的操作来全面创建一个新的迷宫，那么可以使用继承来改变迷宫的一些部分或者该迷宫的建造方式

- Prototype：如果 CreateMaze 由多种原型的房间、墙壁和门对象参数化，它拷贝这些对象增加到迷宫中，那么可以用不同的对象替换这些原型对象改变迷宫的构成

- Singleton：保证每个游戏仅有一个迷宫且所有游戏的对象都可以迅速访问它（不需要使用全局变量或函数），也使得迷宫易于扩展或替换，且不需变动原有的代码
