# visitor

访问者模式：将算法与其他所作用的对象隔离开

## 例子

### 问题

假设正在开发一款能够使用巨型图像中地理信息的应用程序

- 图像中的每个节点既能代表复杂实体(如一座城市)，也能代码更精细的对象(例如工业区旅游景点h)
- 如果节点代表的真实对象之间存在公路， 那么这些节点就会相互连接
- 在程序内部， 每个节点的类型都由其所属的类来表示， 每个特定的节点则是一个对象

一段时间后， 你接到了实现将图像导出到 XML 文件中的任务

- 为每个节点类添加导出函数， 然后递归执行图像中每个节点的导出函数
  - 解决方案简单且优雅： 使用多态机制可以让导出方法的调用代码不会和具体的节点类相耦合

![img](/design-pattern/behavioral-pattern/visitor/assets/image.png)

但系统架构师拒绝对已有节点类进行修改，他认为这些代码已经是产品了，不想冒险对其进行修改，因为修改可能会引入潜在的缺陷

- 他还质疑在节点类中包含导出 XML 文件的代码是否有意义。 这些类的主要工作是处理地理数据。 导出 XML 文件的代码放在这里并不合适
- 在此项任务完成后， 营销部门很有可能会要求程序提供导出其他类型文件的功能， 或者提出其他奇怪的要求。 这样你很可能会被迫再次修改这些重要但脆弱的类。

### 解决方案

访问者模式建议将新行为让如一个名为访问者的独立类中，而不是将其整合到已有类中

- 需要执行操作的原始对象将作为参数被传递给访问者中的方法，让方法能够访问对象所包含的一切必要数据
  - 访问者类可以定义一组 （而不是一个） 方法， 且每个方法可接收不同类型的参数(因为每个节点类可能是不同的)

```ts
class ExportVisitor implements Visitor {
    doForCity(c: City) {
        // ...
    }
    doForIndustry(f: Industry) {
        // ...
    }
    doForSightSeeing(ss SightSeeing) {
        // ...
    }

}

// 使用
// 因为方法不同，所以无法多态机制，需要对他们的类进行检查
for(const node of graph) {
    if(node instanceof City){
        exportVisitor.doForCity(node)
    } else if(node instanceof Industry){
        exportVisitor.doForIndustry(node)
    }
    // ... 
}
// 如果使用相同的方法名称，但是参数不同，即使能够支持重载也不行
// 因为我们无法提前知晓节点对象所属的类，所以重载机制无法执行正确的方法，方法会将节点基类作为输入参数的默认类型
```

不过访问者模式能解决这个问题：使用`双分派`在不使用累赘的条件语句也可下执行正确的方法

- 与其让客户端来选择调用正确版本的方法， 不如将选择权委派给作为参数传递给访问者的对象。 由于该对象知晓其自身的类， 因此能更自然地在访问者中选出正确的方法。 它们会 “接收” 一个访问者并告诉其应执行的访问者方法。

```ts
for(const node of graph) {
    // 最终还是修改到了节点类，但是改动很小，且使得我们在后续进一步添加行为时无需再次修改代码
    node.accept(exportVisitor)
}

class City {
    // ...
    accept(v: Visitor) {
        v.doForCity(this)
    }
}

class Industry {
    // ...
    accept(v: Visitor) {
        v.doForIndustry(this)
    }
}
```

如果我们抽取出所有访问者的通用接口， 所有已有的节点都能与我们在程序中引入的任何访问者交互。 如果需要引入与节点相关的某个行为， 你只需要实现一个新的访问者类即可。

## 参考

<https://refactoringguru.cn/design-patterns/visitor>
